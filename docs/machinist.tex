\documentclass[12pt,a4paper,oneside,openany]{article}
\usepackage[squaren]{SIunits}
%% LaTeX Preamble - Common packages
%\usepackage[german]{babel}
\usepackage{setspace}

\usepackage[T1]{fontenc}
\usepackage{cmap}
\usepackage[utf8]{inputenc} % Any characters can be typed directly from the keyboard, eg √©√ß√±
\usepackage{textcomp} % provide lots of new symbols
\usepackage{graphicx}  % Add graphics capabilities
\usepackage{flafter}  % Don't place floats before their definition
%\usepackage{topcapt}   % Define \topcaption for placing captions above tables (not in gwTeX)
\usepackage[numbers]{natbib} % use author/date bibliographic citations
\usepackage{subfigure}
\usepackage{url}
%\usepackage{babelbib}
\usepackage{booktabs}

\usepackage{amsmath,amssymb}  % Better maths support & more symbols
\usepackage{bm}  % Define \bm{} to use bold math fonts
\usepackage{esint}
\usepackage{algorithm}
%\usepackage[noend]{algorithmic}
\usepackage{algorithmicx}
\usepackage{algpseudocode}

\usepackage[usenames,dvipsnames]{color} 

\usepackage[pdftex,bookmarks,colorlinks,breaklinks]{hyperref}  % PDF hyperlinks, with coloured links
%\definecolor{dullmagenta}{rgb}{0.4,0,0.4}   % #660066
%\definecolor{darkblue}{rgb}{0,0,0.4}
\hypersetup{linkcolor=red,citecolor=blue,filecolor=blue,urlcolor=blue} % coloured links
%\hypersetup{linkcolor=black,citecolor=black,filecolor=black,urlcolor=black} % black links, for print output

\usepackage{memhfixc}  % remove conflict between the memoir class & hyperref
% \usepackage[activate]{pdfcprot}  % Turn on margin kerning (not in gwTeX)
%\usepackage{pdfsync}  % enable tex source and pdf output syncronicity

\usepackage{listings}
\usepackage{nomencl}

%\usepackage{python}
\usepackage{tikz}
%\usetikzlibrary{arrows,decorations.pathmorphing,backgrounds,placments,fit}
\usetikzlibrary{calc,arrows,through,backgrounds,fit,shapes.geometric,shapes.misc,plotmarks}

\usepackage{anysize}
\marginsize{2cm}{2cm}{2cm}{2cm}

\onehalfspacing

\makenomenclature
\def\nomlabel#1{\textbf{#1}\hfil}

\newcommand{\Parameters}{\subsection*{Parameters}}
\newcommand{\ReturnValue}{\subsection*{Return Value}}
\newcommand{\Description}{\subsection*{Description}}
\newcommand{\ClassName}[1]{{\tt #1}}
\newcommand{\ReturnType}[1]{{\tt (#1)}}
%\newcommand{\Function}[1]{{\tt #1()}}
\newcommand{\Self}{{\tt self}}

\DeclareMathOperator{\erf}{erf}
%\DeclareMathOperator{\K}{K}
%\newcommand{\K}{\ensuremath{\mathrm{\large{K}}}}
\newcommand{\ud}{\ensuremath{\mathrm{d}}}
\newcommand{\ii}{\ensuremath{\mathrm{i}}}
\newcommand{\fclamp}{\ensuremath{\mathrm{clamp}}}
\newcommand{\vx}{\ensuremath{\boldsymbol{x}}}
\newcommand{\vv}{\ensuremath{\boldsymbol{v}}}
\newcommand{\va}{\ensuremath{\boldsymbol{a}}}
\newcommand{\vf}{\ensuremath{\boldsymbol{f}}}
\newcommand{\mM}{\ensuremath{\boldsymbol{M}}}
\newcommand{\mW}{\ensuremath{\boldsymbol{W}}}
\newcommand{\mJ}{\ensuremath{\boldsymbol{J}}}
\newcommand{\vq}{\ensuremath{\boldsymbol{q}}}
\newcommand{\vC}{\ensuremath{\boldsymbol{C}}}
\newcommand{\vQ}{\ensuremath{\boldsymbol{Q}}}
\newcommand{\vlambda}{\ensuremath{\boldsymbol{\lambda}}}
\newcommand{\vd}{\ensuremath{\boldsymbol{d}}}
\newcommand{\mI}{\ensuremath{\boldsymbol{I}}}
\newcommand{\vc}{\ensuremath{\boldsymbol{c}}}
\newcommand{\vr}{\ensuremath{\boldsymbol{r}}}
\newcommand{\vF}{\ensuremath{\boldsymbol{F}}}
\newcommand{\vtau}{\ensuremath{\boldsymbol{\tau}}}
\newcommand{\valpha}{\ensuremath{\boldsymbol{\alpha}}}

\newtheorem{mydef}{Definition}


\lstset{numbers=left,basicstyle=\footnotesize,numberstyle=\tiny,tabsize=4,breaklines=true}

\long\def\symbolfootnote[#1]#2{\begingroup%
\def\thefootnote{\fnsymbol{footnote}}\footnote[#1]{#2}\endgroup}


\begin{document}

\tableofcontents

\listoffigures

\section*{About}

This document contains notes about the \em Giddy Machinist \em project.

\section{Straight Skeleton Generation}


The straight skeleton is generated via a two-phase approach. At first, the so-called motorcycle graph is generated, then the actual straight skeleton. One algorithm is described in \cite{ski}.

There are single-phase and two-phase approaches. The two phase approach seems more robust for handling degenerate geometry, for example symmetric polygons, which are very common in practical usage. The two phase approach begins with the motorcycle tracing, which creates clear boundaries for non-convex polygons. 

Another advantage to the two phase approach is that principally, the time complexity of the 2nd phase is greatly reduced, as all events that need to be tracked are of time complexity $O(N+M)$, as there are only collapse events for each edge, as well as the wavefronts opposite of a motorcycle, that need to be tracked.

\subsection{The Motorcycle Graph}

For a simple polygon, motorcycles are only emitted by reflex\footnote{what exactly is a reflex vertex?} vertices. The motorcycles are angular bisector rays, and may crash into each other or the polygon edges as in the game \em Tron\em . A motorcycle trace is terminated when it reaches an edge or other motorcycle trace. A degenerate case, which must be handled for real-world geometry, is when two or more motorcycles collide at the same point, in which case a new motorcycle must be emitted.

\subsubsection{Events}

Three different events may happen during motorcycle tracing:
\begin{description}
\item[Edge Crash] The edge crash is the simplest event, and happens when a motorcycle hits a polygon edge. The edge is split (unless the hit is at an existing vertex), and a new vertex is inserted.
\item[Trace Crash] When a motorcycle hits the trace of another motorcycle, it is terminated, and a vertex is generated.
\item[Merge Crash] When two motorcycles reach the same point in space at the same time, they merge, and may emit one or two new motorcycles in new directions, depending on the crash geometry. This kind of crash can be ignored, and a trace crash can be used instead.
\end{description}


\subsubsection{Special Considerations}

The times for potential crashes do not change during tracing, but new motorcycles may be generated during merges.

Events are treated as simultaneous if they occur within some limit of location and time. As motorcycle events are point-like in nature, there is no danger of invalidating the graph.

\paragraph{Collinear Motorcycles}

A special degenerate case can occur when two motorcycles are collinear, but in opposite directions. In such a case, one of the motorcycles may be discarded. This commonly occurs in CAD data with aligned holes. Cases can occur when only one endpoint is shared, but the other is a trace crash site.

A special difficulty occurs when a motorcycle terminates near an outline vertex, and consequently slightly changes direction as it's nudged into the vertex.


\subsubsection{Tracing Algorithm}

The implementation is outlined in algorithm \ref{alg:mc}. Large performance improvements could be made by eliminating redundant intersection queries.

\begin{algorithm}
\caption{Computation of motorcycle graph.}
\label{alg:mc}
\begin{algorithmic}
\Require{simple input polygon}
\For{each vertex}
	\State create motorcycle structure
\EndFor

\Repeat
	\For{each active motorcycle}
		\State record crash times with edges
		\State record crash times with active motorcycles
		\State record crash times with terminated motorcycles
	\EndFor
	\State sort crash events by time
	\State pick first crash
	\State assemble array off all crash events within merge threshold of location and time from first crash
	\State determine crash subtypes: wall, trace, merge
	\If {contains wall crash} 
		\State all traces terminate at crash site
		\If{not at vertex}
			\State split edge, insert new vertex
		\EndIf
	\ElsIf{contains trace crash}
		\State create new vertex, terminate crashed motorcycles
	\Else
		\State create new vertex, terminate involved motorcycles
		\If{non-convex sub-polygon remains}
			\State start new `escaped' motorcycle
		\EndIf
	\EndIf 

\Until{no more active motorcycles}
\end{algorithmic}
\end{algorithm}

\subsection{Wavefront Propagation}

After the motorcycle graph is generated, the wavefront propagation can be started. Each edge emits a wavefront, which can either collapse, or be split by a motorcycle.

\begin{algorithm}
\caption{Wavefront Initialization.}
\label{alg:wpi}
\begin{algorithmic}
\Require{simple input polygon}
\Require{motorcycle graph}
\For{each motorcycle}
	\State create motorcycle spoke and anti-spoke
\EndFor
\For{each vertex on outline}
	\State create spoke if vertex is convex, and no motorcycle spoke or anti-spoke exists
\EndFor
\For{each each spoke starting at $t=0$}
	\State create wavefront
	\State attach wavefront
\EndFor

\State generate emission events

\For{each wavefront}
	\State compute collapse time
	\State add collapse event to event queue
\EndFor

\For{each branch and merge vertex}
	\State add respective events to event queue
\EndFor

\For{each motorcycle spoke}
	\If{motorcycle starts on outline vertex}
		\State compute split event
	\EndIf
	\If{motorcycle ends on outline vertex}
		\For{each other motorcycle crashed into trace}
			\State compute reverse branch event
		\EndFor
		\If{motorcycle starts on merge vertex}
			\State compute reverse merge event
		\EndIf
	\EndIf
	\If{motorcycles ends and starts on outline}
		\State add earliest event to event queue
	\Else
		\State add split or reverse event to event queue, whichever exists
	\EndIf
\EndFor


\end{algorithmic}
\end{algorithm}

\subsubsection{Wavefront Events}

The following events may occur during wavefront propagation:
\begin{description}
\item[Wavefront Collapse] The collapse is the simplest event. A wavefront collapses into a vertex, which emits a new spoke bisecting the neighbouring wavefronts.
\item[Motorcycle Split] The split occurs along a motorcycle trace, when the motorcycle would hit the opposing face. As the wavefronts are already pre-split along the motorcycle trace, only minor topological changes need to happen.
\item[Motorcycle Branch] A branch occurs when a motorcycle trace reaches a point where another motorcycle will crash into it. The wavefront is split along the incoming motorcycle trace.
\item[Motorcycle Merge] A merge corresponds to the motorcycle merge crash. This event splits the combined wavefront into two sub-wavefronts.
\item[Reverse Merge] Occurs when a merge vertex is reached by the opposing spoke before it is reached by the motorcycles that created it. New wavefronts are inserted between the incoming motorcycles.
\item[Reverse Branch] Occurs when a branch vertex is reached by the opposing spoke before it is reached by the motorcycles that created it. New wavefronts are inserted between the incoming motorcycles.
\item[Emit Contour] When the offset/time of a contour is reached, the wavefront graph can easily be traversed to emit a polygon at this point.
\end{description}

The motorcycle branch and contour emission events are static, thus occur at fixed times that can be computed before the wavefront propagation is started. The collapse and split events, however, are dynamic, and need to be recomputed when certain changes in topology occur.

The reverse merge and branch events can also only be computed dynamically, as when the vertices are hit by backpropagating anti-spokes may depend on previous events.

\subsubsection{Simultaneous Events}

The complex topology of the wavefront graph results in many theoretically degenerate cases, which nevertheless occur in practical applications.

Unlike in the motorcycle tracing phase, degenerate events are not point-like. Resolving degenerate events must not invalidate the graph.

Fortunately, after the separate motorcycle phase, only two classes of degenerate events may occur:
\begin{description}
\item[Arc Collapse] The arc collapse happens when multiple wavefronts collapse into a single point. 
\item[Opposing Wavefronts] This case occurs when the neighbouring wavefronts to the one collapsing are anti-parallel.
\end{description}

Simultaneous collapses should be resolvable sequentially, as long as the temporary resulting wavefronts are allowed to collapse immediately.

\subsubsection{Opposing Wavefronts Collapse and Motorcycle Traces}

When a motorcycle anti-spoke is involved in a degenerate collapse, care must be taken to propagate the anti-spoke correctly.

It appears that the anti-spoke can be dropped in such cases, as cycle-spoke is entering a convex sub-region. This can be detected at the cycle spoke if one of the attached wavefronts collapses, and the new angle bisector `cuts off' the motorcycle trace.

The test for a collapsing anti-spoke is as follows: if the new wavefront travels in the same direction as the anti-spoke, keep it, and split the new wavefront accordingly, otherwise terminate anti-spoke. 

It seems, at this point, that degenerate cases can be handled gracefully, and locally, simply by removing the offending wavefronts from the active list.

%
%\begin{algorithm}
%\caption{Lent's method for computing a finite continued fraction.}
%\label{alg1}
%\begin{algorithmic}
%\IF {$b_0 = 0$} 
%	\STATE $f_0 \gets tiny$
%\ELSE
%	\STATE $f_0 \gets b_0$
%\ENDIF 
%\STATE $C_0 \gets f_0$
%\STATE $1/D_0 \gets 0$
%\FOR{$i = 1,2,3,\ldots$} 
%	\STATE $D_i \gets b_i + a_i / D_{i-1}$
%	\IF {$D_i = 0$} 
%		\STATE $D_i \gets tiny$
%	\ENDIF 
%	\STATE $C_i \gets b_i + a_i C_{i-1}$
%	\IF {$C_i = 0$} 
%		\STATE $C_i \gets tiny$
%	\ENDIF 
%	\STATE $\Delta_i \gets C_i / D_{i}$
%	\STATE $f_i \gets f_{i-1} \Delta_i$
%	\IF {$|\Delta_i-1| < eps$} 
%		\STATE break
%	\ENDIF 
%\ENDFOR
%\end{algorithmic}
%\end{algorithm}
%

\section{FDM Features}

\subsection {Perimeters and Infill}

Typically, it is desired to trace the perimeters of a layer, with one or more traces, and fill the inner volume with a regular pattern, such as alternating straight lines, or a honeycomb.

The outer trace is inset half the extrusion width from the outline, and every further trace a full extrusion width. After the innermost perimeter trace, the patterned area is also inset a full line width.

\subsubsection{Thin Walls}

A thin wall is a section of geometry which is too narrow for a deposited loop of material. It can occur as an original feature of the outline, or as the result of polygon insetting, and the question is how to identify these areas.

It may be possible to look at the history of the wavefront tracing, to peek into the future at any given inset, and determine if a given polygon segment will border a thin wall or not.

By keeping track of the wavefront associated with an emitted line segment, it can be determined if the wavefront terminates before the full trace width is reached. In such a case, the area may be infilled with a pattern, or the skeleton can be traced with a single extrusion. The extrusion width may even be varied, according to the timing of the straight skeleton.

\subsubsection{Thin Walls by Termination Tracking}

Thin wall areas may also be identified by tracking termination time of wavefronts.


\subsection{Sparse Infill, Top and Bottom Layers}

It may be desired to not fully fill the volume, in which case a sparse infill is used, which has traces wider apart than the extrusion width.

However, it is usually desired to fully fill some number of the top and bottom layers. To find out which areas of the layer are top and bottom, respectively, the infill area is compared to the top and bottom layers with a boolean intersection. 

\subsection {Deposition Model}

Printing occurs at a feed rate $v$.

\subsubsection {Nozzle Parameters}

The nozzle is assumed to have a certain diameter $d_N$. From the nozzle, the filament extrudes with a free extrusion diameter $d_F$. The free extrusion diameter depends on other parameters, such as extrusion speed. It is slightly bigger than $d_N$. A default of $$d_F = d_N + \unit{0.08}{\milli\meter}$$ seems to work ok\footnote{Based on Josef Prusa's reprap calculator values.}.

The behavior of $d_F$ should be investigated further, do determine how temperature, extrusion rate, etc., affect it.

From $d_F$ the free extrusion area $$A_F = \frac{1}{4}\pi d_F$$ can be computed.

The extruder flow rate $Q_E = A_E \cdot v_E$, where $v_E$ is the extruder speed, and $A_E$ is the filament cross sectional area, given by $A_E = \frac{1}{4}\pi d_E$. As flow is constant, $Q_E = Q_F$, therefore $Q_F = Q_E$, and $$v_F = A_E / A_F \cdot v_E.$$

\subsubsection {Layer height}

Layer height $h_L$ can be between $20\% - 80\%$ of nozzle diameter\footnote{by anecdotal reference}.

\subsubsection {Layer Width}

The nominal layer width $w_L$ should be at least twice $h_L$. The suggested approach is that the flow rate should be matched to the feed rate, as \em slic3r \em does. This means that $w_L \cdot h_L = A_F$, therefore $$w_L = \frac{A_F}{h_L}.$$

Layer width should not be excessively large, or it may overflow the nozzle left and right.

Using this formula for a 0.35 mm nozzle with 0.2 mm layer height generates a wide layer of 0.72 mm, instead of the more usual 0.5 – 0.6 mm computed by other slicers.

\subsection{Overhangs}

What affects curling on overhangs? arc radius? speed? layer height? cooling? surface tension?

Maybe lowering the print nozzle during overhang prints can counter the curling.

\subsection{Start/End Overlap on Perimeters}

\subsection{Infill generation}

\subsection{Thermal Properties of PLA}

Table \ref{table:plaheat} contains the specific heat values for PLA. A glass transition temperature of $\unit{57}{\celsius}$ is indicated. This corresponds with a king in the specific heat graph.


\begin{table}[htdp]
\caption{Specific heat of PLA, from \cite{mfr}.}
\begin{center}
\begin{tabular}{cc}
\toprule Temperature & Specific Heat ($C_p$)\\
$\celsius$ & $\dfrac{\joule}{\kilo\gram \cdot \kelvin}$ \\
\midrule 52 & 1483 \\
55 & 1590 \\
58 & 1725 \\
60 & 1804 \\
62 & 1851 \\
65 & 1880 \\
70 & 1901 \\
100 & 1955 \\
140 & 1994 \\
160 & 2020 \\
190 & 2060 \\
230 & 2114 \\
\bottomrule 
\end{tabular}
\end{center}
\label{table:plaheat}
\end{table}%

Based on flow rate and specific heat capacity, the amount of heat energy required to melt the filament can be computed, and it can be used for 

%\printnomenclature
\nocite{*}

\bibliographystyle{ieeetr}
\bibliography{machinist}

\end{document}

